<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Selection de zone</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      cursor: crosshair;
      background: #000;
      width: 100vw;
      height: 100vh;
    }

    #screenshot {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      filter: brightness(0.7);
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 10;
    }

    .instruction {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px 40px;
      border-radius: 10px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: 18px;
      pointer-events: none;
      z-index: 1000;
      display: none;
    }

    .instruction.show {
      display: block;
    }

    .help {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: 14px;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <script>
    // Early debug - runs before Tauri module loads
    document.body.style.background = 'black';
    console.log('EARLY SCRIPT RUNNING');
  </script>
  <img id="screenshot" />
  <canvas id="canvas"></canvas>
  <div class="instruction" id="instruction">Dessinez un rectangle pour selectionner</div>
  <div class="help">Glissez pour selectionner | Poignees pour modifier | Entree/Double-clic = capturer | Echap = annuler</div>

  <script>
    const { invoke, convertFileSrc } = window.__TAURI__.core;

    // Log to terminal
    const log = (msg) => invoke('log_message', { message: msg }).catch(() => {});

    const getTime = () => new Date().toISOString().substr(11, 12);
    log('JS inline script loaded');
    console.log('[PERF]', getTime(), 'JS START');

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const screenshotImg = document.getElementById('screenshot');

    // Configurer le canvas en plein ecran
    canvas.width = window.screen.width;
    canvas.height = window.screen.height;

    // ============================================
    // T001: Constants
    // ============================================
    const HANDLE_SIZE = 10;
    const HANDLE_HIT_AREA = 20;
    const MIN_SELECTION_SIZE = 10;

    // ============================================
    // T002: State machine
    // ============================================
    const SelectionState = {
      IDLE: 'idle',
      DRAWING: 'drawing',
      MODIFIABLE: 'modifiable',
      RESIZING: 'resizing',
      MOVING: 'moving'
    };

    const appState = {
      current: SelectionState.IDLE,
      selection: null,
      activeHandle: null,
      dragStart: null,
      drawStart: null
    };

    // ============================================
    // T003: normalizeSelection helper
    // ============================================
    function normalizeSelection(x1, y1, x2, y2) {
      return {
        x: Math.min(x1, x2),
        y: Math.min(y1, y2),
        width: Math.abs(x2 - x1),
        height: Math.abs(y2 - y1)
      };
    }

    // ============================================
    // T004: getHandlePositions helper
    // ============================================
    function getHandlePositions(sel) {
      if (!sel) return {};
      const { x, y, width, height } = sel;
      return {
        nw: { x: x, y: y },
        n:  { x: x + width / 2, y: y },
        ne: { x: x + width, y: y },
        e:  { x: x + width, y: y + height / 2 },
        se: { x: x + width, y: y + height },
        s:  { x: x + width / 2, y: y + height },
        sw: { x: x, y: y + height },
        w:  { x: x, y: y + height / 2 }
      };
    }

    // ============================================
    // T005: getHandleAtPoint helper
    // ============================================
    function getHandleAtPoint(mouseX, mouseY, sel) {
      if (!sel) return null;
      const handles = getHandlePositions(sel);
      const halfHit = HANDLE_HIT_AREA / 2;

      for (const [name, pos] of Object.entries(handles)) {
        if (Math.abs(mouseX - pos.x) <= halfHit && Math.abs(mouseY - pos.y) <= halfHit) {
          return name;
        }
      }
      return null;
    }

    // ============================================
    // T006: isInsideSelection helper
    // ============================================
    function isInsideSelection(mouseX, mouseY, sel) {
      if (!sel) return false;
      return mouseX >= sel.x && mouseX <= sel.x + sel.width &&
             mouseY >= sel.y && mouseY <= sel.y + sel.height;
    }

    // ============================================
    // T007: getCursorForPosition helper
    // ============================================
    function getCursorForPosition(mouseX, mouseY, sel) {
      if (!sel) return 'crosshair';

      const handle = getHandleAtPoint(mouseX, mouseY, sel);
      if (handle) {
        const cursorMap = {
          nw: 'nwse-resize',
          se: 'nwse-resize',
          ne: 'nesw-resize',
          sw: 'nesw-resize',
          n: 'ns-resize',
          s: 'ns-resize',
          e: 'ew-resize',
          w: 'ew-resize'
        };
        return cursorMap[handle];
      }

      if (isInsideSelection(mouseX, mouseY, sel)) {
        return 'move';
      }

      return 'crosshair';
    }

    // ============================================
    // T009: drawSelectionWithHandles
    // ============================================
    function drawSelectionWithHandles(sel) {
      if (!sel) return;

      const { x, y, width, height } = sel;

      // Draw selection rectangle
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, width, height);

      // Semi-transparent fill
      ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
      ctx.fillRect(x, y, width, height);

      // Draw dimensions
      ctx.fillStyle = 'white';
      ctx.font = '14px Arial';
      ctx.fillText(`${Math.round(width)} x ${Math.round(height)}`, x + 5, y + 20);

      // Draw handles
      const handles = getHandlePositions(sel);
      const halfSize = HANDLE_SIZE / 2;

      ctx.fillStyle = 'white';
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;

      for (const pos of Object.values(handles)) {
        ctx.fillRect(pos.x - halfSize, pos.y - halfSize, HANDLE_SIZE, HANDLE_SIZE);
        ctx.strokeRect(pos.x - halfSize, pos.y - halfSize, HANDLE_SIZE, HANDLE_SIZE);
      }
    }

    // ============================================
    // T008: Modified drawSelection for state machine
    // ============================================
    function drawSelection() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (appState.current === SelectionState.DRAWING && appState.drawStart) {
        const sel = normalizeSelection(
          appState.drawStart.x, appState.drawStart.y,
          appState.drawStart.currentX, appState.drawStart.currentY
        );

        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.strokeRect(sel.x, sel.y, sel.width, sel.height);

        ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
        ctx.fillRect(sel.x, sel.y, sel.width, sel.height);

        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.fillText(`${Math.round(sel.width)} x ${Math.round(sel.height)}`, sel.x + 5, sel.y + 20);
      } else if (appState.selection &&
                 (appState.current === SelectionState.MODIFIABLE ||
                  appState.current === SelectionState.RESIZING ||
                  appState.current === SelectionState.MOVING)) {
        drawSelectionWithHandles(appState.selection);
      }
    }

    // ============================================
    // T011-T013, T027: Resize logic with constraints
    // ============================================
    function applyResize(mouseX, mouseY) {
      if (!appState.selection || !appState.activeHandle) return;

      const sel = appState.selection;
      const handle = appState.activeHandle;

      mouseX = Math.max(0, Math.min(canvas.width, mouseX));
      mouseY = Math.max(0, Math.min(canvas.height, mouseY));

      let newX = sel.x;
      let newY = sel.y;
      let newWidth = sel.width;
      let newHeight = sel.height;

      switch (handle) {
        case 'nw':
          newWidth = sel.x + sel.width - mouseX;
          newHeight = sel.y + sel.height - mouseY;
          newX = mouseX;
          newY = mouseY;
          break;
        case 'n':
          newHeight = sel.y + sel.height - mouseY;
          newY = mouseY;
          break;
        case 'ne':
          newWidth = mouseX - sel.x;
          newHeight = sel.y + sel.height - mouseY;
          newY = mouseY;
          break;
        case 'e':
          newWidth = mouseX - sel.x;
          break;
        case 'se':
          newWidth = mouseX - sel.x;
          newHeight = mouseY - sel.y;
          break;
        case 's':
          newHeight = mouseY - sel.y;
          break;
        case 'sw':
          newWidth = sel.x + sel.width - mouseX;
          newHeight = mouseY - sel.y;
          newX = mouseX;
          break;
        case 'w':
          newWidth = sel.x + sel.width - mouseX;
          newX = mouseX;
          break;
      }

      // T027: Handle swap logic for negative dimensions
      if (newWidth < 0) {
        newX = newX + newWidth;
        newWidth = Math.abs(newWidth);
        const swapH = { nw: 'ne', ne: 'nw', sw: 'se', se: 'sw', w: 'e', e: 'w' };
        if (swapH[handle]) appState.activeHandle = swapH[handle];
      }
      if (newHeight < 0) {
        newY = newY + newHeight;
        newHeight = Math.abs(newHeight);
        const swapV = { nw: 'sw', sw: 'nw', ne: 'se', se: 'ne', n: 's', s: 'n' };
        if (swapV[handle]) appState.activeHandle = swapV[handle];
      }

      // T012: Enforce minimum size
      if (newWidth < MIN_SELECTION_SIZE) {
        if (handle.includes('w')) {
          newX = sel.x + sel.width - MIN_SELECTION_SIZE;
        }
        newWidth = MIN_SELECTION_SIZE;
      }
      if (newHeight < MIN_SELECTION_SIZE) {
        if (handle.includes('n')) {
          newY = sel.y + sel.height - MIN_SELECTION_SIZE;
        }
        newHeight = MIN_SELECTION_SIZE;
      }

      // T013: Keep within canvas bounds
      if (newX < 0) {
        newWidth += newX;
        newX = 0;
      }
      if (newY < 0) {
        newHeight += newY;
        newY = 0;
      }
      if (newX + newWidth > canvas.width) {
        newWidth = canvas.width - newX;
      }
      if (newY + newHeight > canvas.height) {
        newHeight = canvas.height - newY;
      }

      appState.selection = { x: newX, y: newY, width: newWidth, height: newHeight };
    }

    // ============================================
    // T018-T019: Move logic with constraints
    // ============================================
    function applyMove(mouseX, mouseY) {
      if (!appState.selection || !appState.dragStart) return;

      const sel = appState.selection;
      const deltaX = mouseX - appState.dragStart.x;
      const deltaY = mouseY - appState.dragStart.y;

      let newX = appState.dragStart.selX + deltaX;
      let newY = appState.dragStart.selY + deltaY;

      // T019: Constrain to canvas bounds
      if (newX < 0) newX = 0;
      if (newY < 0) newY = 0;
      if (newX + sel.width > canvas.width) newX = canvas.width - sel.width;
      if (newY + sel.height > canvas.height) newY = canvas.height - sel.height;

      appState.selection = { x: newX, y: newY, width: sel.width, height: sel.height };
    }

    // Charger la capture d'ecran au demarrage
    async function loadScreenshot() {
      log('loadScreenshot called');
      try {
        log('invoke capture_screen START');
        console.log('[PERF]', getTime(), 'invoke capture_screen START');
        const filePath = await invoke('capture_screen');
        log('invoke capture_screen DONE, path: ' + filePath);
        console.log('[PERF]', getTime(), 'invoke capture_screen DONE');

        log('Setting img.src via asset protocol');
        console.log('[PERF]', getTime(), 'Setting img.src');
        const assetUrl = convertFileSrc(filePath);
        log('Asset URL: ' + assetUrl);
        screenshotImg.src = assetUrl;

        screenshotImg.onload = async () => {
          log('Image loaded successfully');
          console.log('[PERF]', getTime(), 'Image loaded');
          await invoke('show_selection_window');
          log('Window shown');
        };

        screenshotImg.onerror = (e) => {
          log('Image load ERROR: ' + e);
          console.error('[PERF]', getTime(), 'Image load error:', e);
        };
      } catch (error) {
        log('ERROR capturing screen: ' + error);
        console.error('[PERF]', getTime(), 'Error capturing screen:', error);
      }
    }

    // Afficher les instructions au debut
    const instruction = document.getElementById('instruction');
    instruction.classList.add('show');
    setTimeout(() => {
      instruction.classList.remove('show');
    }, 2000);

    // Envoyer la selection et fermer
    async function completeSelection(x, y, width, height) {
      try {
        await invoke('process_selection', {
          bounds: {
            x: Math.round(x),
            y: Math.round(y),
            width: Math.round(width),
            height: Math.round(height)
          }
        });
        await invoke('close_window', { label: 'selection' });
      } catch (error) {
        console.error('Error processing selection:', error);
      }
    }

    // Annuler la selection
    async function cancelSelection() {
      try {
        await invoke('cancel_screenshot');
        await invoke('close_window', { label: 'selection' });
      } catch (error) {
        console.error('Error canceling:', error);
      }
    }

    // ============================================
    // T010, T016, T025: mousedown handler
    // ============================================
    canvas.addEventListener('mousedown', (e) => {
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      if (appState.current === SelectionState.IDLE) {
        appState.current = SelectionState.DRAWING;
        appState.drawStart = { x: mouseX, y: mouseY, currentX: mouseX, currentY: mouseY };

      } else if (appState.current === SelectionState.MODIFIABLE) {
        const handle = getHandleAtPoint(mouseX, mouseY, appState.selection);
        if (handle) {
          appState.current = SelectionState.RESIZING;
          appState.activeHandle = handle;
        } else if (isInsideSelection(mouseX, mouseY, appState.selection)) {
          appState.current = SelectionState.MOVING;
          appState.dragStart = {
            x: mouseX,
            y: mouseY,
            selX: appState.selection.x,
            selY: appState.selection.y
          };
        } else {
          appState.current = SelectionState.DRAWING;
          appState.selection = null;
          appState.drawStart = { x: mouseX, y: mouseY, currentX: mouseX, currentY: mouseY };
          drawSelection();
        }
      }
    });

    // ============================================
    // T011, T015, T018, T021: mousemove handler
    // ============================================
    canvas.addEventListener('mousemove', (e) => {
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      if (appState.current === SelectionState.DRAWING && appState.drawStart) {
        appState.drawStart.currentX = mouseX;
        appState.drawStart.currentY = mouseY;
        drawSelection();

      } else if (appState.current === SelectionState.RESIZING) {
        applyResize(mouseX, mouseY);
        drawSelection();

      } else if (appState.current === SelectionState.MOVING) {
        applyMove(mouseX, mouseY);
        drawSelection();

      } else if (appState.current === SelectionState.MODIFIABLE) {
        const cursor = getCursorForPosition(mouseX, mouseY, appState.selection);
        canvas.style.cursor = cursor;
      } else {
        canvas.style.cursor = 'crosshair';
      }
    });

    // ============================================
    // T014, T020, T022: mouseup handler
    // ============================================
    canvas.addEventListener('mouseup', (e) => {
      if (appState.current === SelectionState.DRAWING && appState.drawStart) {
        const sel = normalizeSelection(
          appState.drawStart.x, appState.drawStart.y,
          appState.drawStart.currentX, appState.drawStart.currentY
        );

        if (sel.width >= MIN_SELECTION_SIZE && sel.height >= MIN_SELECTION_SIZE) {
          appState.selection = sel;
          appState.current = SelectionState.MODIFIABLE;
          appState.drawStart = null;
          drawSelection();
        } else {
          completeSelection(0, 0, canvas.width, canvas.height);
        }

      } else if (appState.current === SelectionState.RESIZING) {
        appState.current = SelectionState.MODIFIABLE;
        appState.activeHandle = null;

      } else if (appState.current === SelectionState.MOVING) {
        appState.current = SelectionState.MODIFIABLE;
        appState.dragStart = null;
      }
    });

    // ============================================
    // T024: Double-click to confirm
    // ============================================
    canvas.addEventListener('dblclick', (e) => {
      if (appState.current === SelectionState.MODIFIABLE && appState.selection) {
        if (isInsideSelection(e.clientX, e.clientY, appState.selection)) {
          const sel = appState.selection;
          completeSelection(sel.x, sel.y, sel.width, sel.height);
        }
      }
    });

    // ============================================
    // T023: keydown handler
    // ============================================
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        cancelSelection();
      } else if (e.key === 'Enter') {
        if (appState.selection) {
          const sel = appState.selection;
          completeSelection(sel.x, sel.y, sel.width, sel.height);
        } else {
          completeSelection(0, 0, canvas.width, canvas.height);
        }
      }
    });

    // Charger la capture au demarrage
    log('About to call loadScreenshot');
    loadScreenshot();
    log('loadScreenshot called (async)');
  </script>
</body>
</html>
