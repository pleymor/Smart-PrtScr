<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Selection de zone</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      cursor: crosshair;
      background: #000;
      width: 100vw;
      height: 100vh;
    }

    #screenshot {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      filter: brightness(0.7);
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 10;
    }

    .instruction {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px 40px;
      border-radius: 10px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: 18px;
      pointer-events: none;
      z-index: 1000;
      display: none;
    }

    .instruction.show {
      display: block;
    }

    .help {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: 14px;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <script>
    // Early debug - runs before Tauri module loads
    document.body.style.background = 'black';
    console.log('EARLY SCRIPT RUNNING');
  </script>
  <img id="screenshot" />
  <canvas id="canvas"></canvas>
  <div class="instruction" id="instruction">Dessinez un rectangle pour selectionner</div>
  <div class="help">Glissez pour selectionner | Poignees pour modifier | Entree/Double-clic = capturer | Echap = annuler</div>

  <script>
    const { invoke, convertFileSrc } = window.__TAURI__.core;

    // Log to terminal
    const log = (msg) => invoke('log_message', { message: msg }).catch(() => {});

    const getTime = () => new Date().toISOString().substr(11, 12);
    log('JS inline script loaded');
    console.log('[PERF]', getTime(), 'JS START');

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const screenshotImg = document.getElementById('screenshot');

    // Configurer le canvas en plein ecran
    canvas.width = window.screen.width;
    canvas.height = window.screen.height;

    // ============================================
    // Constants
    // ============================================
    const HANDLE_SIZE = 10;
    const HANDLE_HIT_AREA = 20;
    const MIN_SELECTION_SIZE = 10;

    // Text colors for timestamp preview
    const textColors = {
      white: '#ffffff',
      black: '#000000',
      gray: '#808080',
      red: '#ff0000',
      green: '#00ff00',
      blue: '#0000ff',
      yellow: '#ffff00',
      cyan: '#00ffff',
      magenta: '#ff00ff'
    };

    // ============================================
    // T002: State machine
    // ============================================
    const SelectionState = {
      IDLE: 'idle',
      DRAWING: 'drawing',
      MODIFIABLE: 'modifiable',
      RESIZING: 'resizing',
      MOVING: 'moving'
    };

    const appState = {
      current: SelectionState.IDLE,
      selection: null,
      activeHandle: null,
      dragStart: null,
      drawStart: null,
      timestampOptions: null
    };

    // ============================================
    // T003: normalizeSelection helper
    // ============================================
    function normalizeSelection(x1, y1, x2, y2) {
      return {
        x: Math.min(x1, x2),
        y: Math.min(y1, y2),
        width: Math.abs(x2 - x1),
        height: Math.abs(y2 - y1)
      };
    }

    // ============================================
    // T004: getHandlePositions helper
    // ============================================
    function getHandlePositions(sel) {
      if (!sel) return {};
      const { x, y, width, height } = sel;
      return {
        nw: { x: x, y: y },
        n:  { x: x + width / 2, y: y },
        ne: { x: x + width, y: y },
        e:  { x: x + width, y: y + height / 2 },
        se: { x: x + width, y: y + height },
        s:  { x: x + width / 2, y: y + height },
        sw: { x: x, y: y + height },
        w:  { x: x, y: y + height / 2 }
      };
    }

    // ============================================
    // T005: getHandleAtPoint helper
    // ============================================
    function getHandleAtPoint(mouseX, mouseY, sel) {
      if (!sel) return null;
      const handles = getHandlePositions(sel);
      const halfHit = HANDLE_HIT_AREA / 2;

      for (const [name, pos] of Object.entries(handles)) {
        if (Math.abs(mouseX - pos.x) <= halfHit && Math.abs(mouseY - pos.y) <= halfHit) {
          return name;
        }
      }
      return null;
    }

    // ============================================
    // T006: isInsideSelection helper
    // ============================================
    function isInsideSelection(mouseX, mouseY, sel) {
      if (!sel) return false;
      return mouseX >= sel.x && mouseX <= sel.x + sel.width &&
             mouseY >= sel.y && mouseY <= sel.y + sel.height;
    }

    // ============================================
    // T007: getCursorForPosition helper
    // ============================================
    function getCursorForPosition(mouseX, mouseY, sel) {
      if (!sel) return 'crosshair';

      const handle = getHandleAtPoint(mouseX, mouseY, sel);
      if (handle) {
        const cursorMap = {
          nw: 'nwse-resize',
          se: 'nwse-resize',
          ne: 'nesw-resize',
          sw: 'nesw-resize',
          n: 'ns-resize',
          s: 'ns-resize',
          e: 'ew-resize',
          w: 'ew-resize'
        };
        return cursorMap[handle];
      }

      if (isInsideSelection(mouseX, mouseY, sel)) {
        return 'move';
      }

      return 'crosshair';
    }

    // ============================================
    // loadTimestampOptions: Fetch timestamp settings from backend
    // ============================================
    async function loadTimestampOptions() {
      try {
        const options = await invoke('get_timestamp_options');
        appState.timestampOptions = options;
        log('Timestamp options loaded: ' + JSON.stringify(options));
      } catch (error) {
        log('Error loading timestamp options: ' + error);
        appState.timestampOptions = null;
      }
    }

    // ============================================
    // drawTimestampPreview: Render timestamp on selection
    // ============================================
    function drawTimestampPreview(sel, options) {
      if (!sel || !options || !options.enabled) return;

      const { x, y, width, height } = sel;

      // Generate timestamp in French format
      const now = new Date();
      const timestamp = now.toLocaleDateString('fr-FR') + ' ' + now.toLocaleTimeString('fr-FR');

      // Build font style
      let fontStyle = '';
      if (options.bold) fontStyle += 'bold ';
      if (options.italic) fontStyle += 'italic ';
      const fontSize = options.fontSize || 14;
      const font = `${fontStyle}${fontSize}px Arial`;

      ctx.font = font;
      const textMetrics = ctx.measureText(timestamp);
      const textWidth = textMetrics.width;

      const isOverlay = options.type === 'overlay';
      const isBannerLight = options.type === 'banner-light';
      const isBannerDark = options.type === 'banner-dark';
      const isTop = options.position === 'top';
      const bannerHeight = fontSize + 20;

      // Calculate text X position based on alignment
      let textX;
      const padding = 10;
      switch (options.textAlign) {
        case 'left':
          textX = x + padding;
          break;
        case 'right':
          textX = x + width - textWidth - padding;
          break;
        case 'center':
        default:
          textX = x + (width - textWidth) / 2;
          break;
      }

      // Get text color
      const textColor = textColors[options.textColor] || '#ffffff';

      if (isOverlay) {
        // Overlay mode: draw text directly on image area
        const textY = isTop ? y + fontSize + padding : y + height - padding;

        ctx.fillStyle = textColor;
        ctx.fillText(timestamp, textX, textY);

        // Draw underline if enabled
        if (options.underline) {
          ctx.strokeStyle = textColor;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(textX, textY + 3);
          ctx.lineTo(textX + textWidth, textY + 3);
          ctx.stroke();
        }
      } else {
        // Banner mode: draw banner outside selection
        const bannerColor = isBannerLight ? '#f5f5f5' : '#333333';
        const bannerY = isTop ? y - bannerHeight : y + height;

        // Draw banner background
        ctx.fillStyle = bannerColor;
        ctx.fillRect(x, bannerY, width, bannerHeight);

        // Draw banner border
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, bannerY, width, bannerHeight);

        // Calculate text position in banner
        const textY = bannerY + (bannerHeight + fontSize) / 2 - 2;

        // Adjust textX for banner
        switch (options.textAlign) {
          case 'left':
            textX = x + padding;
            break;
          case 'right':
            textX = x + width - textWidth - padding;
            break;
          case 'center':
          default:
            textX = x + (width - textWidth) / 2;
            break;
        }

        ctx.fillStyle = textColor;
        ctx.fillText(timestamp, textX, textY);

        // Draw underline if enabled
        if (options.underline) {
          ctx.strokeStyle = textColor;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(textX, textY + 3);
          ctx.lineTo(textX + textWidth, textY + 3);
          ctx.stroke();
        }
      }
    }

    // ============================================
    // drawSelectionWithHandles
    // ============================================
    function drawSelectionWithHandles(sel) {
      if (!sel) return;

      const { x, y, width, height } = sel;

      // Draw selection rectangle
      ctx.strokeStyle = '#00ff00';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, width, height);

      // Semi-transparent fill
      ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
      ctx.fillRect(x, y, width, height);

      // Draw dimensions
      ctx.fillStyle = 'white';
      ctx.font = '14px Arial';
      ctx.fillText(`${Math.round(width)} x ${Math.round(height)}`, x + 5, y + 20);

      // Draw timestamp preview
      drawTimestampPreview(sel, appState.timestampOptions);

      // Draw handles
      const handles = getHandlePositions(sel);
      const halfSize = HANDLE_SIZE / 2;

      ctx.fillStyle = 'white';
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;

      for (const pos of Object.values(handles)) {
        ctx.fillRect(pos.x - halfSize, pos.y - halfSize, HANDLE_SIZE, HANDLE_SIZE);
        ctx.strokeRect(pos.x - halfSize, pos.y - halfSize, HANDLE_SIZE, HANDLE_SIZE);
      }
    }

    // ============================================
    // drawSelection: Main drawing function for state machine
    // ============================================
    function drawSelection() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (appState.current === SelectionState.DRAWING && appState.drawStart) {
        const sel = normalizeSelection(
          appState.drawStart.x, appState.drawStart.y,
          appState.drawStart.currentX, appState.drawStart.currentY
        );

        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.strokeRect(sel.x, sel.y, sel.width, sel.height);

        ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
        ctx.fillRect(sel.x, sel.y, sel.width, sel.height);

        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.fillText(`${Math.round(sel.width)} x ${Math.round(sel.height)}`, sel.x + 5, sel.y + 20);

        // Draw timestamp preview during drawing
        drawTimestampPreview(sel, appState.timestampOptions);
      } else if (appState.selection &&
                 (appState.current === SelectionState.MODIFIABLE ||
                  appState.current === SelectionState.RESIZING ||
                  appState.current === SelectionState.MOVING)) {
        drawSelectionWithHandles(appState.selection);
      }
    }

    // ============================================
    // T011-T013, T027: Resize logic with constraints
    // ============================================
    function applyResize(mouseX, mouseY) {
      if (!appState.selection || !appState.activeHandle) return;

      const sel = appState.selection;
      const handle = appState.activeHandle;

      mouseX = Math.max(0, Math.min(canvas.width, mouseX));
      mouseY = Math.max(0, Math.min(canvas.height, mouseY));

      let newX = sel.x;
      let newY = sel.y;
      let newWidth = sel.width;
      let newHeight = sel.height;

      switch (handle) {
        case 'nw':
          newWidth = sel.x + sel.width - mouseX;
          newHeight = sel.y + sel.height - mouseY;
          newX = mouseX;
          newY = mouseY;
          break;
        case 'n':
          newHeight = sel.y + sel.height - mouseY;
          newY = mouseY;
          break;
        case 'ne':
          newWidth = mouseX - sel.x;
          newHeight = sel.y + sel.height - mouseY;
          newY = mouseY;
          break;
        case 'e':
          newWidth = mouseX - sel.x;
          break;
        case 'se':
          newWidth = mouseX - sel.x;
          newHeight = mouseY - sel.y;
          break;
        case 's':
          newHeight = mouseY - sel.y;
          break;
        case 'sw':
          newWidth = sel.x + sel.width - mouseX;
          newHeight = mouseY - sel.y;
          newX = mouseX;
          break;
        case 'w':
          newWidth = sel.x + sel.width - mouseX;
          newX = mouseX;
          break;
      }

      // T027: Handle swap logic for negative dimensions
      if (newWidth < 0) {
        newX = newX + newWidth;
        newWidth = Math.abs(newWidth);
        const swapH = { nw: 'ne', ne: 'nw', sw: 'se', se: 'sw', w: 'e', e: 'w' };
        if (swapH[handle]) appState.activeHandle = swapH[handle];
      }
      if (newHeight < 0) {
        newY = newY + newHeight;
        newHeight = Math.abs(newHeight);
        const swapV = { nw: 'sw', sw: 'nw', ne: 'se', se: 'ne', n: 's', s: 'n' };
        if (swapV[handle]) appState.activeHandle = swapV[handle];
      }

      // T012: Enforce minimum size
      if (newWidth < MIN_SELECTION_SIZE) {
        if (handle.includes('w')) {
          newX = sel.x + sel.width - MIN_SELECTION_SIZE;
        }
        newWidth = MIN_SELECTION_SIZE;
      }
      if (newHeight < MIN_SELECTION_SIZE) {
        if (handle.includes('n')) {
          newY = sel.y + sel.height - MIN_SELECTION_SIZE;
        }
        newHeight = MIN_SELECTION_SIZE;
      }

      // T013: Keep within canvas bounds
      if (newX < 0) {
        newWidth += newX;
        newX = 0;
      }
      if (newY < 0) {
        newHeight += newY;
        newY = 0;
      }
      if (newX + newWidth > canvas.width) {
        newWidth = canvas.width - newX;
      }
      if (newY + newHeight > canvas.height) {
        newHeight = canvas.height - newY;
      }

      appState.selection = { x: newX, y: newY, width: newWidth, height: newHeight };
    }

    // ============================================
    // T018-T019: Move logic with constraints
    // ============================================
    function applyMove(mouseX, mouseY) {
      if (!appState.selection || !appState.dragStart) return;

      const sel = appState.selection;
      const deltaX = mouseX - appState.dragStart.x;
      const deltaY = mouseY - appState.dragStart.y;

      let newX = appState.dragStart.selX + deltaX;
      let newY = appState.dragStart.selY + deltaY;

      // T019: Constrain to canvas bounds
      if (newX < 0) newX = 0;
      if (newY < 0) newY = 0;
      if (newX + sel.width > canvas.width) newX = canvas.width - sel.width;
      if (newY + sel.height > canvas.height) newY = canvas.height - sel.height;

      appState.selection = { x: newX, y: newY, width: sel.width, height: sel.height };
    }

    // Charger la capture d'ecran au demarrage
    async function loadScreenshot() {
      log('loadScreenshot called');
      try {
        // Load timestamp options first
        await loadTimestampOptions();

        log('invoke capture_screen START');
        console.log('[PERF]', getTime(), 'invoke capture_screen START');
        const filePath = await invoke('capture_screen');
        log('invoke capture_screen DONE, path: ' + filePath);
        console.log('[PERF]', getTime(), 'invoke capture_screen DONE');

        log('Setting img.src via asset protocol');
        console.log('[PERF]', getTime(), 'Setting img.src');
        const assetUrl = convertFileSrc(filePath);
        log('Asset URL: ' + assetUrl);
        screenshotImg.src = assetUrl;

        screenshotImg.onload = async () => {
          log('Image loaded successfully');
          console.log('[PERF]', getTime(), 'Image loaded');
          await invoke('show_selection_window');
          log('Window shown');
        };

        screenshotImg.onerror = (e) => {
          log('Image load ERROR: ' + e);
          console.error('[PERF]', getTime(), 'Image load error:', e);
        };
      } catch (error) {
        log('ERROR capturing screen: ' + error);
        console.error('[PERF]', getTime(), 'Error capturing screen:', error);
      }
    }

    // Afficher les instructions au debut
    const instruction = document.getElementById('instruction');
    instruction.classList.add('show');
    setTimeout(() => {
      instruction.classList.remove('show');
    }, 2000);

    // Envoyer la selection (fenetre reste ouverte pour apercu en temps reel)
    async function completeSelection(x, y, width, height) {
      try {
        await invoke('process_selection', {
          bounds: {
            x: Math.round(x),
            y: Math.round(y),
            width: Math.round(width),
            height: Math.round(height)
          }
        });
        // Window stays open - filename-dialog will close it when Save is clicked
      } catch (error) {
        console.error('Error processing selection:', error);
      }
    }

    // Annuler la selection
    async function cancelSelection() {
      try {
        await invoke('cancel_screenshot');
        // Close dialog if it exists (ignore error if not open)
        await invoke('close_window', { label: 'filename-dialog' }).catch(() => {});
        await invoke('close_window', { label: 'selection' });
      } catch (error) {
        console.error('Error canceling:', error);
      }
    }

    // ============================================
    // T010, T016, T025: mousedown handler
    // ============================================
    canvas.addEventListener('mousedown', (e) => {
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      if (appState.current === SelectionState.IDLE) {
        appState.current = SelectionState.DRAWING;
        appState.drawStart = { x: mouseX, y: mouseY, currentX: mouseX, currentY: mouseY };

      } else if (appState.current === SelectionState.MODIFIABLE) {
        const handle = getHandleAtPoint(mouseX, mouseY, appState.selection);
        if (handle) {
          appState.current = SelectionState.RESIZING;
          appState.activeHandle = handle;
        } else if (isInsideSelection(mouseX, mouseY, appState.selection)) {
          appState.current = SelectionState.MOVING;
          appState.dragStart = {
            x: mouseX,
            y: mouseY,
            selX: appState.selection.x,
            selY: appState.selection.y
          };
        } else {
          appState.current = SelectionState.DRAWING;
          appState.selection = null;
          appState.drawStart = { x: mouseX, y: mouseY, currentX: mouseX, currentY: mouseY };
          drawSelection();
        }
      }
    });

    // ============================================
    // T011, T015, T018, T021: mousemove handler
    // ============================================
    canvas.addEventListener('mousemove', (e) => {
      const mouseX = e.clientX;
      const mouseY = e.clientY;

      if (appState.current === SelectionState.DRAWING && appState.drawStart) {
        appState.drawStart.currentX = mouseX;
        appState.drawStart.currentY = mouseY;
        drawSelection();

      } else if (appState.current === SelectionState.RESIZING) {
        applyResize(mouseX, mouseY);
        drawSelection();

      } else if (appState.current === SelectionState.MOVING) {
        applyMove(mouseX, mouseY);
        drawSelection();

      } else if (appState.current === SelectionState.MODIFIABLE) {
        const cursor = getCursorForPosition(mouseX, mouseY, appState.selection);
        canvas.style.cursor = cursor;
      } else {
        canvas.style.cursor = 'crosshair';
      }
    });

    // ============================================
    // T014, T020, T022: mouseup handler
    // ============================================
    canvas.addEventListener('mouseup', (e) => {
      if (appState.current === SelectionState.DRAWING && appState.drawStart) {
        const sel = normalizeSelection(
          appState.drawStart.x, appState.drawStart.y,
          appState.drawStart.currentX, appState.drawStart.currentY
        );

        if (sel.width >= MIN_SELECTION_SIZE && sel.height >= MIN_SELECTION_SIZE) {
          appState.selection = sel;
          appState.current = SelectionState.MODIFIABLE;
          appState.drawStart = null;
          drawSelection();
          emitSelectionBounds(); // Notify dialog of new selection
        } else {
          // Too small selection - create fullscreen selection
          appState.selection = { x: 0, y: 0, width: canvas.width, height: canvas.height };
          appState.current = SelectionState.MODIFIABLE;
          appState.drawStart = null;
          drawSelection();
          emitSelectionBounds();
        }

      } else if (appState.current === SelectionState.RESIZING) {
        appState.current = SelectionState.MODIFIABLE;
        appState.activeHandle = null;
        emitSelectionBounds(); // Notify dialog of resized selection

      } else if (appState.current === SelectionState.MOVING) {
        appState.current = SelectionState.MODIFIABLE;
        appState.dragStart = null;
        emitSelectionBounds(); // Notify dialog of moved selection
      }

      // Bring dialog back to front after any mouse interaction
      invoke('focus_dialog').catch(() => {});
    });

    // ============================================
    // T024: Double-click - no longer confirms (selection stays modifiable)
    // ============================================
    // Double-click disabled - user must click Save in dialog to confirm

    // ============================================
    // T023: keydown handler - only Escape to cancel
    // ============================================
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        cancelSelection();
      }
      // Enter no longer confirms - user must click Save in dialog
    });

    // ============================================
    // createFullscreenSelection: For fullscreen capture mode
    // ============================================
    function createFullscreenSelection() {
      log('Creating fullscreen selection');
      appState.selection = {
        x: 0,
        y: 0,
        width: canvas.width,
        height: canvas.height
      };
      appState.current = SelectionState.MODIFIABLE;
      drawSelection();
      // Emit bounds after a short delay to ensure emit function is available
      setTimeout(() => emitSelectionBounds(), 100);
    }

    // ============================================
    // Event listener for fullscreen capture trigger
    // ============================================
    const { listen, emitTo } = window.__TAURI__.event;

    // Emit selection bounds to filename-dialog for save
    function emitSelectionBounds() {
      if (appState.selection) {
        const bounds = {
          x: Math.round(appState.selection.x),
          y: Math.round(appState.selection.y),
          width: Math.round(appState.selection.width),
          height: Math.round(appState.selection.height)
        };
        // Use emitTo to target the filename-dialog window specifically
        emitTo('filename-dialog', 'selection-bounds-changed', bounds);
        log('Emitted selection-bounds-changed: ' + JSON.stringify(bounds));
      }
    }
    listen('capture-full-screen', () => {
      log('capture-full-screen event received');
      createFullscreenSelection();
    });

    // ============================================
    // Event listener for timestamp options changes from filename-dialog
    // ============================================
    log('Registering timestamp-options-changed listener...');
    listen('timestamp-options-changed', (event) => {
      log('timestamp-options-changed event received: ' + JSON.stringify(event.payload));
      appState.timestampOptions = event.payload;
      drawSelection();
    }).then(() => {
      log('timestamp-options-changed listener registered successfully');
    }).catch((err) => {
      log('ERROR registering timestamp-options-changed listener: ' + err);
    });

    // Charger la capture au demarrage
    log('About to call loadScreenshot');
    loadScreenshot();
    log('loadScreenshot called (async)');
  </script>
</body>
</html>
